/*Задача о замыканиях и области видимости: напишите функцию, которая возвращает другую функцию. 
Внутренняя функция должна иметь доступ к переменной, определенной во внешней функции, даже после того, 
как внешняя функция завершила свое выполнение.


В этом примере innerFunction сохраняет доступ к переменной outerVariable, 
которая была определена во внешней функции outerFunction, даже после завершения выполнения outerFunction. 
Такое поведение возможно благодаря замыканию: внутренняя функция сохраняет ссылку на переменные своего внешнего контекста, 
даже после того, как внешняя функция завершила свою работу.
*/

function outerFunction() {
  let outerVariable = 'Я доступна во внутренней функции!';

  function innerFunction() {
      console.log(outerVariable);
  }

  // Возвращаем внутреннюю функцию
  return innerFunction;
}

// Создаем функцию, которая хранит внутреннюю функцию из outerFunction
let myFunction = outerFunction();

// Вызываем возвращенную функцию
myFunction(); // Выводит: Я доступна во внутренней функции!
  

/* 
Функции, возвращающие другие функции с доступом к локальным переменным внешней функции, 
часто используются в JavaScript для создания приватных переменных и методов в объектах или модулях. 
Вот несколько примеров, когда такое может понадобиться:

Использование в модулях: Модули являются одним из основных способов организации кода в JavaScript. 
Функции, возвращающие другие функции, могут использоваться для создания замыканий, 
обеспечивающих приватность переменных и методов внутри модуля.
*/

/* 
let myModule = (function() {
    let privateVariable = 'Скрытая информация';

    function privateMethod() {
        console.log('Это приватный метод');
    }

    return {
        publicMethod: function() {
            console.log(privateVariable);
            privateMethod();
        }
    };
})();

myModule.publicMethod(); // Выводит: Скрытая информация
*/

/* 
Управление состоянием в React и Redux: 
В библиотеках React и Redux замыкания используются для управления состоянием компонентов и хранилища данных.
*/

/* 
function Counter() {
    let count = 0;

    return {
        increment: function() {
            count++;
            console.log('Текущее значение:', count);
        },
        decrement: function() {
            count--;
            console.log('Текущее значение:', count);
        },
        getCount: function() {
            return count;
        }
    };
}

let counter = Counter();
counter.increment(); // Выводит: Текущее значение: 1
counter.increment(); // Выводит: Текущее значение: 2
counter.decrement(); // Выводит: Текущее значение: 1
console.log(counter.getCount()); // Выводит: 1
*/
